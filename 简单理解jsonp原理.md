> 对于`Javascript`程序员来说，发送`ajax`请求获取后台数据然后把数据和模板拼接成字符串渲染回`DOM`进行无刷新更新页面这样的操作可谓是轻车熟路。但众所周知，`ajax`有一个不好，就是不能跨域传输数据，而跨域传输有时候又是必须用到的，比如我们可能需要调用第三方网站提供的某些`API`来获取某些信息，提供给我们网站的用户。

### 一、概述 

例如，要开发一个天气应用，你可能需要调用第三方的天气API，这个时候就必然涉及到跨域请求数据，因为毕竟我们不可能为了开发一个天气应用就自己搭建一个天气API。在少数情况下，如果第三方网站的服务器上设置了CORS机制，这时是可以直接用ajax发送请求的。但在大多数情况下，第三方网站都没有这么慷慨，因为涉及到安全问题，不可能允许任意人都能自由调用自己网站的接口。这个时候jsonp就应运而生了。
 
在`HTML`中有这样一类标签，它们都有一个`src`属性，`src`属性的值是一个链接，当标签一被解析到`DOM`中，就会开始把`src`属性中的链接指向的资源下载到本文档，例如，设置了`src`的`<img>`标签会自动从`src`属性的链接中下载资源，下载的资源又会被浏览器解析成图片，加到`DOM`中；设置了`src`属性的`<iframe>`元素会从`src`链接里下载一张网页；设置了`src`属性的`<script>`元素也会自动从src链接里下载`Javascript`代码并执行，而这个过程中`DOM`本身也是没有刷新的，更令人心动的是，`src`属性的链接根本没有同域的限制。这个原理就是实现`jsonp`的基石。

### 二、原理

但是，我们想用它来实现跨域还很有难度。这个`src`属性的元素的加载和一般的`ajax`请求有一个很大的不同，回想一下，在一个典型的`ajax`请求中，我们可以完全控制请求的过程，我们可以对指定的网页实行`open`，可以设置请求头，可以指定响应的`MIMEtype`，关键的是，我们可以从`xhr`对象的`responseText`属性中 __截取响应数据__ ，然后拼接模板，渲染`DOM`。但在`<img>`, `<iframe>`, `<script>`这些标签中呢，我们的控制权就被剥夺了，我们设置`src`属性，浏览器负责发送请求，服务器端返回的响应直接就被加载回`DOM`了，我们根本 __没有插手修改数据的机会__ 。
 
怎么办呢？这就像向遥远的深空发射一艘飞船，当飞船远离我们几十光年的时候，我们就不太可能从地面对它发送实时控制信号了，更好的做法就是把指令提前写在飞船上，让它自动执行。
 
和飞船的例子一样，一个典型的`jsonp`过程就是：创建一个`<script>`标签，设置`src`属性，这个`src`属性中包括了目标`API`的地址，我们的查询字符串`querystring`，`querystring`中最最重要的是我们的 __“指令”__，因为`<script>`标签`src`返回之后，我们并不能控制返回的结果，所以最好让服务器返回的时候自己执行我们想要执行的操作。这个 __“指令”__ 也就是`jsonp`中的“p”了。
 
举一个栗子：

__1.__ 我需要某个数据，比如就按照前面讲的，天气数据吧，于是我构造查询`url`。注意这里的`instruction`就是我们告诉服务器的“指令”。我们跟服务器说，我需要`province`为`hubei`，`city`为`wuhan`的地方的天气数据，但由于数据返回后我自己不能处理，所以你返回数据的时候自己处理好了，具体怎么处理，我已经写在名字叫做`instruction`的指令里面了。 

```javascript
var script = document.createElement('script');
script.src = 'www.weather.fake/get/?province=hubei&city=wuhan&callback=instruction';

document.getElementsByTagName('head')[0].appendChild(script);
```

__2.__ 先写好 __指令__，即回调。

```javascript
function instruction(data){
    console.log(data);
}
```

__3.__ `weather.fake`的服务器收到我的请求，从数据库里一找，找到了数据。一看，还有个指令，于是它就执行`instruction`指令。说起来很高级，实际上也就是把返回的数据包裹在`instruction`函数里面(`jsonp`的`p`，`padding`)。服务器于是返回这样一个东西：

```javascript
//response.js
instruction({
　　"city":"wuhan",
　　"weather":"cloudy"
}) 
```
 
__4.__ 服务器端的`writeheader`设置和浏览器端的`accept`设置会保证返回的东西会被浏览器解释成一个`js`文件，于是我们事先写好的指令`instruction函数`就得到了执行，整个`jsonp`过程就完成了。
 
### 三、需要注意的几点
 
1. 返回的`js`文件是在全局作用域执行的，所以你要保证你写的回调函数`instruction`在全局作用域里。
 
 
2. 这里的`callback=instruction`。其中，`callback`只是一个普通的`querystring`，是你和服务器事先约定的，不同`API`提供方，名字也不同，有的可能就叫`cb`，等等。至于`instruction`，你爱写什么写什么，但要保证和你写的回调处理函数名字一致。我这里为了方便理解，就写`instruction`了。
 
### 四、ajax跨域，危险在哪里？

有些人说，禁止`ajax`跨域，是为了防止攻击者利用它向自己的服务器发送敏感信息（例如`cookie`等等），这显然是错误的。对于一个已经被注入攻击代码的网站，攻击者如果只是想向自己的服务器发送信息而已，就算不用`ajax`，也完全可以用`img`等标签直接向自己的服务器执行`get`请求发送数据，况且创建一个`img`标签可比写一个完整的`ajax`过程简单多了，根本用不着兴师动众，也就是说， __`javascript`攻击中单向GET请求中ajax并没有优势__。
 
为什么要限制`ajax`，因为它太强大了。看看`CORS`机制，它规定的是服务器方面的接受白名单。也就是说，由服务器来决定可以接受哪些客户可以向它请求数据。说明 __跨域限制主要是为了保证服务器端安全的__ 。
 
> 关键在于，一般能用`src`做到的，`ajax`都能做到，`ajax`能做到的`src`却不一定能够做到。`src`只能发起`get`请求，但`ajax`能发起任意类型的请求。
 
举个栗子，某博客网站的删除文章功能`API`可能必须要用`delete`方法发送请求才能执行，这个时候攻击者如果只用`src`构造请求就无能为力了，但`ajax`却可以轻易模拟用户动作。这个时候禁止跨域就显得很重要了。
 
假设我的攻击网站是`www.evil.com`。而一个允许CORS跨域传输`ajax`的博客网站是`www.blog.com`。该博客网站中，当用户点击了删除按钮时，就会向服务器发送`delete`请求。具体为：`www.blog.com/user/delete(?id=10000)` 。这个时候，假如用户访问我的`evil.com`网站，而我在我网站的脚本里写`ajax`：

```javascript
$.ajax({
    url:'www.blog.com/user/delete',
    method:'delete',
    data:{id:10000},
})
```

这样是可能成功的，因为当向`www.blog.com`发送`ajax`时，会自动带上用户在该网站的`cookie`，而请求方法又合法，所以如果服务器方面依赖`cookie`进行身份验证的话，这样能取得`blog.com`服务器的信任，也就能不知不觉地删除用户在`blog.com`上写的文章。
